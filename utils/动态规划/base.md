### 动态规划
+ **重叠子问题**(Overlapping Subproblems)：一个问题可以被分解为若干个子问题，且这些子问题会重复出现
+ **最优子结构**(Optimal Substructure)：一个问题的最优解可以由其子问题的最优解有效的构造出来  

**一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决**  
<br/>

### 递归与递推
+ 递归写法的计算方式是**自顶向下**，即从目标问题开始，将其分解为子问题的组合，直到分解至边界为止
+ 递推写法的计算方式是**自底向上**，即从边界开始，不断向上解决问题，直到解决了目标问题  

动态规划消除递归过程中产生的大量重叠子问题的两种方法：**记忆化搜索** 和 **自底向上递推**  
<br/>

### 动态规划与分治
+ 动态规划和分治都是将问题分解为子问题，然后合并子问题的解得到原问题的解
+ 而分治法分解出的**子问题是不重叠的**，而动态规划解决的问题拥有**重叠子问题**
+ 另外，分治法解决的问题不一定是最优化问题，而动态规划解决的问题一定是最优化问题  
<br/>

### 动态规划与贪心
+ 动态规划和贪心都要求原问题必须拥有**最优子结构**
+ 而贪心由于具有**贪心选择性质**，保证了子问题只会被计算一次，不会被多次计算，因此贪心算法其实是最简单的动态规划
   + 贪心选择性质，是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到
   + 对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的一个整体最优解
+ 在动态规划算法中，每步所作的选择往往依赖于相关子问题的解，因此只有在解出相关子问题后，才能作出选择
+ 而在贪心算法中，仅在当前状态下作出最好选择，即局部最优选择，然后再去解作出这个选择后产生的相应的子问题
   + 贪心算法所作的贪心选择可以依赖于以往所作过的选择，但决不依赖于将来所作的选择，也不依赖于子问题的解
+ 动态规划算法通常以自底向上的方式解各子问题
+ 而贪心算法则通常以自顶向下的方式进行
   + 贪心算法以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为一个规模更小的子问题
